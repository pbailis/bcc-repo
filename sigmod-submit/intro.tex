
\section{Introduction}
\label{sec:intro}

% coordination-freedom provides scalability

Minimizing coordination is key in high-performance, scalable database
design. Coordination---informally, the requirement that concurrently
executing operations communicate or otherwise stall in order to
complete---is expensive. Coordination prohibits parallel execution,
limits availability in the presence of partial failures, and incurs
potentially high latency as communication costs increase (e.g.,
wide-area networks)~\cite{hat-vldb,gilbert-cap}. A system without
synchronous coordination (i.e., that is \textit{coordination-free})
can scale aggressively: adding more query processing capacity (e.g.,
servers) does not incur additional overhead because queries can
execute independently. In contrast with scale-out across multiple data
items (as in ``shared-nothing''
designs~\cite{bernstein-book,f1,spanner,pnuts,hstore}), \cfreedom
allows scale-out even at the granularity of a single contended data
item and ensures both high availability~\cite{gilbert-cap} and low
latency execution~\cite{pacelc}.

% serializability is traditional answer to correctness, but requires
% coordination

Unfortunately, traditional approaches to maintaining correct data
during concurrent access are at odds with the goal of \cfreedom. The
serializable transaction concept provides concurrent operations
(transactions) with the illusion of executing in some serial
order~\cite{bernstein-book}. Serializability is \textit{sufficient} to
guarantee application-level correctness, or \textit{consistency}: if
individual transactions maintain correct application state, then a
serially ordered execution will not violate
correctness~\cite{gray-virtues}. However, serializability incurs a
steep coordination cost: at the level of reads and writes, any write
potentially conflicts with any other read or write to the same item,
requiring coordination for safe
execution~\cite{hat-vldb,davidson-survey}. A proliferation of
alternative data management solutions (e.g., ``NoSQL'') offer greater
scalability by foregoing such strong
semantics~\cite{dynamo,optimistic} but, in practice, require end-users
to make ad-hoc decisions to determine when weakened semantics are
acceptable for applications~\cite{consistency-borders}.

% which anomalies matter depends on application; think about
% invariants instead, use to identify necessary and sufficient
% condition

In this paper, we seek an alternative: coordination-avoiding
concurrency control strategies that coordinate only when it is
provably \textit{necessary} for correctness. For arbitrary
applications, \textit{anomalies} resulting from non-serializable
execution~\cite{adya-isolation} may compromise application
correctness: for example, multiple users might be assigned the same
username, or, in a classic example, a bank account balance might be
negative. Our task is to categorize and only prevent those anomalies
that can violate application-level consistency---without requiring
users to reason about low-level isolation models~\cite{hat-vldb}
themselves. This requires more information about applications than
traditional~\cite{bernstein-book,gray-virtues} (but not
all~\cite{eswaran-consistency,korth-serializability,decomp-semantics,garciamolina-semantics,activedb-book,ic-survey,ic-survey-two})
transaction models: users will specify \textit{invariants} (i.e.,
integrity constraints)~\cite{traiger-tods}, or predicates representing
application-level correctness criteria that should always hold true
across database state(s). For example, users might inform the database
that user IDs should be unique and that each customer should belong to
a bank branch (e.g., via schema annotations).

To provide a formal basis for coordination-avoidance, we develop a
necessary and sufficient condition for \cfree execution under a given
set of invariants, called \textit{invariant confluence}. This
\iconfluence formalizes---at an application level---which operations
can be safely executed independently and in parallel and subsequently
``merged'' into consistent database state. We prove that a database
system can maintain invariants during \cfree, available, and
convergent operation if and only if the invariants are \iconfluent
with respect to an application's transactions. Accordingly,
\iconfluence analysis can capture the potential scalability of a given
application: if an application passes the \iconfluence test, it can be
executed without coordination. If an application fails the test, it
will (provably) \textit{have} to coordinate in order to guarantee
correctness. As we discuss in Section~\ref{sec:relatedwork}, our core
results marry concepts from rule-based rewriting
systems~\cite{obs-confluence,termrewriting}, distributed
computing~\cite{herlihy-apologizing,gilbert-cap,hat-vldb}, and many
prior database concepts~\cite{activedb-book,ic-survey,ic-survey-two}
such as semantics-based concurrency
control~\cite{sdd1,decomp-semantics,badrinath-semantics,garciamolina-semantics,korth-serializability,atomictransactions,weihl-thesis},
in the context of (logically) replicated state.

% many workloads are amenable to cfree execution! the following ICs
% are actually okay. but if not, here's the cost.

We subsequently apply our \iconfluence analysis to existing
applications and quantify the costs of coordination. Specifically, we
demonstrate that transaction execution under many common integrity
constraints are indeed achievable without coordination, including
forms of foreign key constraints, unique value generation, and
row-level check constraints. In contrast, others, like unique value
invariants and sequence number generation do not. We apply this
analysis to existing benchmarks to determine their required degree of
coordination: surprisingly, many are executable without
coordination. As a case study, we focus on the TPC-C
benchmark~\cite{tpcc}, which has seen substantial popularity in the
database community as a gold standard for new concurrency control
algorithms~\cite{abadi-vll,jones-dtxn,schism,calvin,hstore,oltpbench}. We
show that, in fact, ten of twelve of TPC-C's integrity constraints are
\iconfluent and, more importantly, compliant TPC-C can be implemented
without synchronous coordination across servers. As a proof of
concept, we scale a simple coordination-avoiding database prototype
linearly, to over $1.6M$ New-Order transactions per second on a
$100$-node EC2 cluster. We also discuss other applications and
demonstrate the costs of coordination by analyzing upper bounds on
throughput due to to atomic commitment overhead.

Overall, our results provide a formal but pragmatic grasp on the
trade-off between coordination and application-level consistency. We
accordingly view this work as the first step in revisiting core
database concepts like query optimization, failure recovery, and data
layout in light of coordination avoidance and increased knowledge of
application-level semantics.


