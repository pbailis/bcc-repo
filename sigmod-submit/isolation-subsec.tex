\subsection{From Applications to Isolation Models}

Even if an application is \iconfluent and therefore achievable with
coordination-freedom, application designers (or, ideally, a database
system) may still wish to choose an appropriate isolation model. There
are two primary decisions a system faces: how should new updates be
made visible (with respect to other updates), and how quickly should
updates be made visible (with respect to real time)?

\minihead{Making updates visible} Ideally, users could instead use
\textit{no} concurrency control or \textit{eventual consistency} to
disseminate their \iconfluent updates. However, this can lead to
anomalies: for example, applying multi-item writes without concurrency
control might result in a situation where readers observe some writes
but not the others, violating a declared foreign key constraint. There
are two models we have identified as particularly useful. The first,
the \textit{happens-before} relation from
causality~\cite{lamportclocks} informally ensures that, if a write is
visible, the writes that influenced the write are also visible. This
is useful in the case that a user reads a write (e.g., read
\textit{department.id=20}) and one of her subsequent writes depends on
that write (e.g., insert \textit{user.department=20}). We can use a
degenerate form of happens-before---so-called \textit{explicit
  causality}~\cite{explicit-socc2012} to ensure that, if a user issues
a write to an item that explicitly (via a forign key dependency)
depends on a previously write, the latter is only observed with the
former. The second model, \textit{Read Atomic isolation}
(RA)~\cite{ramp-txns} ensures that, once one of the writes in a
transaction is visible to a reader, all are visible (e.g., a single
transaction inserts \textit{department.id=20} and
\textit{user.department=20}).

Given our \cfree model of divergent replicas with merges, if merge
respects explicit causality (defined with respect to $I$) and RA
isolation, $I$ will not be violated. Given that causal consistency is
known to have substantial metadata overheads (which explicit causality
mitigates to some extent~\cite{explicit-socc2012}) and that the best
known implementation of RA isolation~\cite{ramp-txns} requires two
rounds of communication for reads and writes, these models are best
employed only when necessary. In \lang, we need only employ them in
the case of foreign key updates.

\minihead{Controlling recency} While individual replicas may respect
invariants, users often desire \textit{recency} guarantees on their
updates: guarantees on the visibility of their updates, either to
their own future transactions (e.g., read-your-writes guarantees) or
to other users (e.g., linearizability). A class of guarantees from the
distributed systems and database literature called \textit{session
  guarantees} enforces the former, often via so-called \textit{sticky
  availability}: all of a user's transactions are executed against the
same (logical) copy of the database. This satisfies common
requirements like reading one's prior writes and can be used to
implement more complex models such as PRAM~\cite{pram} and
causal~\cite{lamportclocks} recency guarantees. The latter (more
generally, global real-time recency guarantees) may require
coordination. A bounded-staleness guarantee can indeed be provided
with periodic broadcasts between replicas: in the failure-free case,
this is \cfree with respect to individual requests, but, in the
presence of failures, may sacrifice availability. More stringent
guarantees like linearizability will require coordination for
updates. As Bailis et al. note, these distributed systems guarantees
are largely orthogonal to traditional ACID semantics~\cite{hat-vldb}
(e.g., traditional serializability does not place any recency
guarantees on cross-transaction recency) but are often of interest to
practitioners (typically, in weaker forms like read-your-writes).
