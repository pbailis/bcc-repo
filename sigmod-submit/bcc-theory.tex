
\section{Freedom and \iconfluence}
\label{sec:bcc-theory}

To begin, we answer the question: under what conditions does an
operation require synchronous replica communication? The answer will
depend on the set of operations the database may be expected to
perform as well as the integrity constraints that the database is
required to maintain.

\fullnameconfluence (hereafter, \iconfluence) ensures that if the
effects of two series of separate transactions ($T_i$, $T_j$) that
operate independently on the same copy of valid database state are
valid ($I(T_i(D))$, $I(T_j(D))$ hold), their effects can safely be
combined to produce a valid ``merged'' database state ($I(p_i(D)
\sqcup p_j(D))$ holds).

We first define a valid sequence of transformations:

\begin{definition}[Valid Sequence]
Given invariant $I$, $T_i(D) = t_{i1}(\dots t_{in}(D))$ is an
$I$-valid sequence of transactions in $T$ if each $t_{ij} \in T$ and
each $t_{ik}(\dots t_{in}(D))$ is valid under $I$.
\end{definition}

\begin{definition}[\iconfluence]
Given invariant $I$, transactions $T$ are $I$-confluent, for all
$I$-valid sequences $T_1$, $T_2$ of transactions in $T$, $I(T_1(D_0))
\wedge I(T_2(D_0)) \Rightarrow I(T_1(D_0) \sqcup T_2(D_0))$.
\end{definition}

Informally, the \iconfluence property ensures that the set of valid
sequences with a common ancestor are closed under merge. Even less
formally, our forumulation of \iconfluence will be familiar to users
of fork-join programming models (e.g., Git). \iconfluence allows users
to ``check out'' a known good copy of database state ($I(D)$) and
perform modifications to the state in isolation---as long as these
modifications are ``safe'' ($I(T_i(D))$ is true). Under \iconfluent
operations, any concurrent modifications to database state can be
safely ``merged'' to provide a valid database state ($I(T_1(D) \cup
T_2(D))$ is true). As we have alluded, the validity of a given merge
depends on the semantics of each individual update: an experienced
programmer can likely think of several operations and invariants that
are not \iconfluent as well as many that are. For example, if $I=$no
bank account has negative balance, then $P=\{$\textit{increment user
  A's balance by 100, increment user A's balance by 50}$\}$ is
\iconfluent, as is $P\cup\{$\textit{audit the database and store the
  sum of user balances in the \textrm{audit} table} but not
$P\cup\{$\textit{decrement user A's balance by 200}$\}$. For now, we
defer a discussion of the space of operations until
Section~\ref{sec:bcc-practice}. 

\miniheadnostop{A note on \iconfluence} Our notion of \iconfluence
differs from that of prior work: we directly incorporate a user's
application-level invariants as part of transaction execution. We
discuss specific trade-offs in Section~\ref{sec:relatedwork}, but we
believe that this definition is more general than alternatives like
state-based commutativity or traditional Church-Rosser confluence. As
a simple example due to Lamport, in a banking application, the balance
calculated by an audit transaction may change depending on whether a
deposit transaction is executed before or after the audit. These two
transactions are not commutative at the level of database state but
\textit{do} commute with respect to the invariant that the database
does not contain negative account balances. The use of invariants
instead of states will allow us to specify a \textit{necessary} and
sufficient condition (instead of simply a sufficient condition) for
coordination.

\iconfluence is particularly useful because it is deeply connected to
coordination-free execution:

\begin{theorem}
\label{theorem:necessary}
An always valid system can guarantee an application with transactions
$T$ and invariants $I$ with \cfreedom, transactional availability,
convergence if and only if $T$ are $I$-confluent.
\end{theorem}

Proving Theorem~\ref{theorem:necessary} is not particularly difficult
and is largely a reformulation of Gilbert and Lynch's partitioning
arguments. Informally, if \iconfluence holds, each replica can simply
check each transaction's modifications locally and replicas can simply
merge independent modifications to guarantee convergence. For the
converse, we construct a scenario under which a replica cannot
determine whether or not a non-confluent update should be aborted
without contacting another replica.

\begin{proof}
($\Leftarrow$) We begin with the simpler proof, which is by
  construction. Assume an invariant $I$ and set of transactions $I$
  are $I$-confluent. Consider a system in which, for each transaction
  that each database replica receives, it executes the transaction
  against a copy of its current state and checks whether or not the
  resulting state is valid under $I$ or not. If the resulting state is
  valid, the replica commits the transaction. If not, the replica
  aborts the transaction. Replicas exchange copies of their local
  states and union them. No replica will contain an invalid
  modification, and, because $T$ is $I$-confluent, the merge of any
  two valid sequences (constructed above) is valid; therefore, the
  converged database state will be confluent.

($\Rightarrow$) Assume a system S exists that can guarantee always
  valid operation for a set of transactions $T$ with \cfreedom,
  transactional availability, and convergence, but $T$ is not
  $I$-confluent. Then there exists valid sequences $T_1,T_2$ in $T$
  such that $I(T_1(D_0)) \wedge I(T_2(D_0))$ but $I(T_1(D_0) \sqcup
  I(T_2(D_0))$ is false. We now construct two executions of $S$ to
  produce a contradiction. Consider an execution $\alpha_0$ in which
  one replica $R_1$ executes the transactions from $T_1$ and a second
  execution $\alpha_1$ in which a second replica $R_2$ executes the
  transactions from $T_2$ and each replica initially contains the
  initial state $D_0$. Without synchronous communication, a third
  execution $\alpha_2$ in which $\alpha_1 \dot \alpha_2$---$T_1$ is
  submitted to $R_1$ and $T_2$ is submitted to $R_2$ is, from the
  perspective of $R_1$, indistinguishable from $\alpha_1$, and, from
  the perspective of $R_2$, indistinguishable from $\alpha_2$. To
  preserve availability, in $\alpha_1$ and $\alpha_2$, $R_1$ and $R_2$
  cannot choose to abort any of $T_1$ or $T_2$, yet, in $\alpha_3$, if
  $R_1$ and $R_2$ each commit their respective sequences, the merged
  state will be invalid. Therefore, $R_1$ and $R_2$ must either give
  up one of \cfreedom, transactional availability, or convergence, as
  desired.
\end{proof}

Formalism aside, \iconfluence captures a simple rule;
informally: \textbf{Coordination is only required when a transaction's
  actions cannot be reconciled with concurrent actions.}
Alternatively (and much less formally): \textbf{Any two valid database
  states must be mergeable into another database state.}

\minihead{Revisiting Payroll} With \iconfluence in hand, we can
revisit our payroll example. As we showed by counterexample,
uniqueness of arbitrary values is not \iconfluent: $\{$Stan:5$\}$ and
$\{$Mary:5$\}$ are both valid states that can be reached by valid
sequences (starting at $\{\}$) but their merge---$\{$Stan:5,
Mary:5$\}$ is not valid. Therefore, insertion of arbitrary values is
not $I$-confluent for $I=\{$unique IDs$\}$. However, deletion of
employees \textit{is} $I$-confluent: removing items from a bag of
unique values cannot introduce duplicates. We can repeat the same
exercise for foreign key constraints: inserting new records with valid
department IDs cannot in fact introduce merge conflicts. The salary
constraint is similarly easily validated for simple insert
statements. In the next section, we will expand this analysis to a
full SQL dialect.
