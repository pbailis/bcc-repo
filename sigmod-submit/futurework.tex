
\section{Discussion and Future Work}
\label{sec:discussion}

lifecycle management: what if I want to add another transaction or run
an ad-hoc transaction?

how far to go on language analysis?

difference between state-based and invariant-based commutativity: toot
horn re: 1.) necessary and sufficient and 2.) easier to reason about
app invariants than return values of functions (meet application
developers at their own level of abstraction).

opportunity: query planning for coordination; bring up
producer-consumer scenario

data layout for coordination: schism is sort of like this; the
question is whether you can go further---heterogeneous
hardware/layout/load, dynamic load balancing

usability and invariant specification: example-based learning, also:
conservative analysis with programmer debugging; again, this starts to
get into PL--whether this is where we should be going is another
question. we are bullish that, by annotating a few extra datatypes, we
can get away with quite a bit.
