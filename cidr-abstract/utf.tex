% flatex input: [bcc.tex]
% !TeX encoding   = UTF-8

\documentclass[9pt]{article}

\usepackage{fullpage}
\usepackage{balance,array}
\usepackage[bf]{subfigure}

\let\proof\relax
\let\endproof\relax

\usepackage{color, times, mathptmx, amsmath, amssymb, amsthm, verbatim, 
  mdwlist, graphicx, footnote, multirow, xspace, tikz, colortbl,cite,microtype}

\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\let\footnotesize\small

\usepackage{algorithm}% http://ctan.org/pkg/algorithms

\usepackage[noend]{algpseudocode}% http://ctan.org/pkg/algorithmicx

% Franklin, Alvaro, Conway, Venkataraman, Panda

\setlength{\parskip}{3ex plus 2ex minus 2ex}

\algrenewcommand{\alglinenumber}[1]{\small#1:}

\theoremstyle{definition}
\setlength{\textfloatsep}{1em}% Remove \textfloatsep

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

\newtheorem{invariant}{Invariant}
\newtheorem{lemma}{Lemma}

\makeatletter
\def\thm@space@setup{\thm@preskip=.5em
\thm@postskip=.5em}
\makeatother

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{myproof}{Proof}
\newtheorem{claim}{Claim}

\theoremstyle{remark}

\newtheorem{remark}{Remark}

\usepackage{scrextend}
\usepackage[hyphens]{url}

\usepackage[hidelinks]{hyperref}
\usepackage{breakurl}

\newcommand{\commentt}[1]{{\small\texttt{#1}}}

\newcommand{\example}[1]{{\vspace{.25em}\noindent\textbf{#1.} }}
\newcommand{\miniheadnostop}[1]{{\vspace{.4em}\noindent\textit{#1} }}
\newcommand{\minihead}[1]{{\vspace{.4em}\noindent\textbf{#1.} }}
\newcommand{\miniheadnopd}[2]{{\vspace{.4em}\noindent\textbf{#1}\hspace{.5em}{#2}\vspace{.4em} }}
\newcommand{\minidef}[1]{{\vspace{.25em}\noindent\textit{#1} }}

\newcommand{\pbnote}[1]{{\color{red}{#1 ---P.B.}}}

\newcommand{\ttf}[1]{\texttt{#1}\xspace}

\newcommand{\cfree}{coordination-free\xspace}
\newcommand{\cfreedom}{coordination-freedom\xspace}


\newcommand{\fullnameconfluence}{invariant confluence\xspace}
\newcommand{\iconfluent}{$\mathcal{I}$-confluent\xspace}
\newcommand{\iconfluence}{$\mathcal{I}$-confluence\xspace}



\newcommand{\ramp}{ANON\xspace}


\newcommand{\dpc}{\ttf{D-2PC}}
\newcommand{\cpc}{\ttf{C-2PC}}


\hyphenation{da-ta-base}
\hyphenation{pre-ven-tion-}
\hyphenation{non-de-ter-min-is-tic}

\newcommand{\rapl}{\ttf{RAMP-L}}
\newcommand{\raps}{\ttf{RAMP-S}}
\newcommand{\rapb}{\ttf{RAMP-B}}

\newcommand{\lwlr}{\ttf{LWLR}}
\newcommand{\lwsr}{\ttf{LWSR}}
\newcommand{\lwnr}{\ttf{LWNR}}
\newcommand{\nwnr}{\ttf{NWNR}}
\newcommand{\mstr}{\ttf{MSTR}}

\usepackage{etoolbox}
\newcommand{\zerodisplayskips}{%
  \setlength{\abovedisplayskip}{4pt}
  \setlength{\belowdisplayskip}{4pt}
  \setlength{\abovedisplayshortskip}{4pt}
  \setlength{\belowdisplayshortskip}{4pt}}
\appto{\normalsize}{\zerodisplayskips}
\appto{\small}{\zerodisplayskips}
\appto{\footnotesize}{\zerodisplayskips}

\usepackage[T1]{fontenc}
\renewcommand{\ttdefault}{fi4}

\newenvironment{myitemize}
{
  \vspace{-.5em}
    \begin{list}{$\bullet$ }{}
        \setlength{\topsep}{0em}
        \setlength{\parskip}{0pt}
        \setlength{\partopsep}{0pt}
        \setlength{\parsep}{0pt}         
        \setlength{\itemsep}{.4em} 
        \setlength{\itemindent}{0em}
}
{
    \end{list} 
    \vspace{-.5em}
}

\newenvironment{introenumerate}
{

   \vspace{-.75em}
   \newcounter{qdcounter}
    \begin{list}{\arabic{qdcounter}.~}{\usecounter{qdcounter}\leftmargin=1em}
        \setlength{\topsep}{0em}
        \setlength{\parskip}{0pt}
        \setlength{\partopsep}{0pt}
        \setlength{\parsep}{0pt}         
        \setlength{\itemsep}{1em} 
        \setlength{\itemindent}{0em}
}
{
    \end{list} 
    \vspace{-.75em}
}

\setlength{\parskip}{.3em}

\usepackage[leftmargin=0em]{quoting}

\begin{document}

\thispagestyle{empty}


%
% --- Author Metadata here ---
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\begin{center}
{\textbf{\large{Bridging the Gap: Opportunities in Coordination-Avoiding Database Research}}}\\[1mm]
{\fontsize{11pt}{12pt}\selectfont{{Peter Bailis, Alan Fekete{\fontsize{12}{14}$^\dagger$}, Ali Ghodsi, Michael J. Franklin, Joseph M. Hellerstein, Ion Stoica\\{\small{UC Berkeley and {\fontsize{12}{14}$^\dagger$}University of Sydney}}}}}
\end{center}\vspace{-.5em}

% flatex input: [intro.tex]

\noindent\textbf{Abstract.} \textit{Weakly consistent systems surface a controversial tension between, on the one hand, availability, latency, and performance, and, on the other, programmability. We propose the concept of coordination avoidance as a unifying, underlying principle behind the former and discuss lessons from our recent experiences mitigating the latter.}

\minihead{Trouble in paradise} Faced with the task of operating ``always on'' services and lacking sufficient guidance from the literature regarding alternative distributed designs and algorithms, many Internet service architects and engineers throughout the 2000s discarded traditional database semantics and transactional models in favor of weaker but less principled models: eventual consistency, few if any multi-object, multi-operation (i.e., transactional) guarantees, and ad-hoc application-specific compensation---collectively, much of NoSQL~\cite{queue}. From a research perspective, this space of weaker models has proven to be a fertile area: new (or re-discovered), often esoteric, and almost always nuanced semantics present many opportunities for systems designs, optimizations, and formalism.

Unfortunately, these weaker models come with serious usability disadvantages: programmability suffers. Understanding the implications of choosing a non-serializable isolation model is a difficult task. Users of have little to no practical guidance as to how to choose an appropriate model for their applications, and understanding the differences between models effectively requires graduate-level training in distributed systems and/or database theory~\cite{consistency-borders}. Members within the internet services industry that birthed the resurgence of interest in these semantics have begun a backlash against them: one recent and prominent industrial account unequivocally states that ``designing applications to cope with concurrency anomalies in their data is...ultimately not worth the performance gains''~\cite{f1}. Statements like these (which, in our experience, enjoy some popularity among practitioners and considerable acceptance in the database community~\cite{stonebraker-blog}) suggest that, as a research community, we are either failing to communicate and demonstrate the benefits of these weak semantics, have underestimated the burden placed on programmers, or a combination of both.

\minihead{Coordination-avoidance: a fundamental theme} In tribute to the CAP Theorem~\cite{gilbert-cap} that popularized this debate, much of the dialogue around weakly consistent models concerns the availability of operations under failures. Availability is an important property, but, in our opinion, a sole focus on availability undervalues the benefits of weak semantics. Abadi successfully argues that, while ``availability'' is only relevant in the presence of failures, weakly consistent (``AP'') systems can also offer low latency~\cite{pacelc}. We would take Abadi's position even further: weak consistency also allows aggressive scale-out, even at the level of a single data item---more servers can be added without communication between them. Indeed, modern, strongly consistent ``NewSQL'' systems can provide horizontal scale-out using shared-nothing database replication techniques popularized in the 1980s~\cite{sharednothing}. However, especially for worst-case accesses, these systems are far from ``as scalable as NoSQL''~\cite{f1} systems offering weak isolation. In recent research, we have examined the throughput penalties associated with these ``strong'' models: in modern LAN and WAN networks, distributed serializable transactions face a worst-case bound of 1200 and 12 read-write transactions per item per second, independent of implementation strategy. Recent systems~\cite{spanner,f1} are no exception: operations over disjoint data can proceed concurrently, increasing throughput, but operations over non-disjoint data are limited by network latency.

The three properties above---availability, low latency, and scale-out---are consequences of a more fundamental principle underlying weakly consistent systems: a lack of synchronous communication, or coordination, between concurrent operations. If operations can execute coordination-free, they can run concurrently, on any available resources, without coommunication with or stalling of concurrent operations. The cost of coordination is easily and simultaneously cast in the form of (minority) unavailability, latency (minimum 1 RTT), and throughput (maximum \textasciitilde$\frac{1}{\texttt{RTT}}$). Moreover, and more importantly, the concept of coordination-free execution is portable to more system architectures: whereas traditional formulations of availability are inherently tied to physical replication, coordination-freedom is a property of the execution strategy and is independent of physical deployment or topology. For example, a system providing clients with snapshot reads can effectively act as a coordination-free ``replicated'' system even if implemented by a set of linearizable multi-versioned masters~\cite{ramp-txns}. Judicious use of weak semantics in correct application execution equates to \textit{coordination-avoidance}~\cite{coord-avoid}: the use of as little coordination as possible.

\minihead{Bridging the gap} As F1's authors highlight above~\cite{f1}, the decision to consider coordination-avoiding algorithms or not requires a cost-benefit judgment~\cite{queue}: will performance, availability, or latency benefits outweigh the cost of ascertaining whether weak models are sufficient? In a sober assessment, many applications will likely be able to (over-)pay for ``strong consistency'': single-site operations are inexpensive~\cite{sharednothing}, while improvements in datacenter networks~\cite{bobtail} lower the cost for non-geo-replicated systems. Yet, a large class of applications---for example, non-partitionable applications~\cite{tao}, applications with high mutation rates (i.e., write contention)~\cite{tpcc}, or geo-replicated applications~\cite{swift}---will not be as tolerant of extraneous coordination costs.

Identifying and serving this latter class of applications is paramount to ensuring the future adoption of coordination-avoiding algorithms. While represents a difficult task, we offer three examples from our recent research:

\begin{myitemize}
\item \textbf{ACID databases are not built using ACID transactions.} High-performance database internals are maintained using specialized, highly optimized algorithms that are carefully designed to maximize safe concurrency~\cite{gray-book} (e.g., in the case of indexing, exotic data structures like B-link trees~\cite{blink-tree}). The database designer does not use serializable access to the database data structures for at least two reasons. First, doing so would be prohibitively expensive, and, second, the expert designer does not need to: she has a well-defined specification (e.g., secondary index lookup behavior) that she can use to ensure correctness (without end-user intervention). In a distributed database system, coordination-avoiding techniques are applicable to internal data structure maintenance. As experts of both databases and fast distributed algorithms, we can ensure that the anomalies of our weakly consistent but fast algorithms do not interfere with application-level correctness; we can encapsulate the side-effects of weak semantics behind well-defined (and existing) interfaces. Our recent work on Read Atomic Multi-Partition (RAMP) transactions was developed in this context and, as motivating use cases, focuses on foreign key constraint maintenance, distributed secondary indexing, and materialized view maintenance~\cite{ramp-txns}.

\item \textbf{Applications on ACID databases (surprisingly often) do not use ACID transactions.} Traditional databases also have an equivalent of weak consistency: although they were not explicitly developed for distributed environments, databases provide a range of ``weak isolation'' models, such as Read Committed and Repeatable Read. Many ``ACID'' databases today adopt these weak isolation guarantees by default (only 3 of 18 in a survey we recently performed) and sometimes as the strongest level supported (e.g., Oracle 11G)~\cite{hat-vldb}. Existing applications deployed on these systems are necessarily either tolerant of or otherwise must for compensate for these weak semantics, hinting at opportunities for optimization. Moreover, while many of these weak semantics are achievable in a coordination-free manner, their typical \textit{implementations} are not and require expensive locking or validation protocols---a remnant of their single-node origins. We recently classified commonly-deployed isolation models as achievable via ``Highly Available Transactions'' or not~\cite{hat-vldb} and believe the further study of these applications and associated semantics can bear additional fruit.

\item \textbf{High-value, well-specified applications are ripe for optimization.} We have found success in coordination-avoiding optimization of high-value workloads. As an example, we recently combined the above RAMP transactions with our recent results on coordination-free integrity constraints to attain an order-of-magnitude improvement in performance on the challenging TPC-C OLTP benchmark~\cite{coord-avoid,tpcc}. Coincidentally, as the industry- and academic-standard benchmark for transactional performance, TPC-C is accompanied by a rigorous specification of correctness, which was instrumental in guiding our implementation strategy. We have subsequently encountered few database workloads and integrity constraints that require coordination for \textit{all} queries. The resulting challenge is two-fold: first, identify the operations that \textit{do} require coordination (ideally few or none), and second, determine an appropriate coordination-free execution plan for those that do not.  \end{myitemize}

Overall, we have found success in $i.)$ focusing on existing applications and $ii.)$ incorporating existing specifications to enable coordination-avoiding execution. Towards these goals, our ongoing research directly incorporates application-level invariants (derived from real-world application and the SQL language) for analysis under a necessary and sufficient property for coordination-free execution~\cite{coord-avoid}. The use of application-level invariants is key to safely maximizing concurrency without requiring programmer expertise in weak isolation models.

\minihead{A coordinated future} The continued success of weakly consistent systems requires a focus on utility. Delivering an understanding of exactly \textit{why} these weakly consistent semantics can provide (in a fundamental sense) greater availability, lower latency, and higher throughput is paramount; our proposed focus on \textit{coordination avoidance} is our best attempt to do so. By applying the lens of coordination avoidance to a range of existing, well-defined and ideally high-value domains, we have the opportunity to demonstrate exactly \textit{when} weak consistency is adequate and, equally importantly, when it is not. Without a full specification, language techniques~\cite{calm,blazes} and domain-specific optimizations~\cite{crdt} are helpful to programmers. However, with a full specification and increased knowledge of application semantics~\cite{coord-avoid,ramp-txns}, we can fully realize the benefits of coordination avoidance while further mitigating programmer burden.

% flatex input end: [intro.tex]

% --- End of Author Metadata ---

%*flatex input: [bcc.bbl]
\begin{thebibliography}{10}

\bibitem{pacelc}
D.~J. Abadi.
\newblock Consistency tradeoffs in modern distributed database system design:
  {CAP} is only part of the story.
\newblock {\em IEEE Computer}, 45(2):37--42, 2012.

\bibitem{consistency-borders}
P.~Alvaro, P.~Bailis, N.~Conway, and J.~M. Hellerstein.
\newblock Consistency without borders.
\newblock In {\em SoCC 2013}.

\bibitem{blazes}
P.~Alvaro, N.~Conway, J.~M. Hellerstein, and D.~Maier.
\newblock Blazes: Coordination analysis for distributed programs.
\newblock In {\em ICDE 2014}.

\bibitem{calm}
P.~Alvaro, N.~Conway, J.~M. Hellerstein, and W.~Marczak.
\newblock Consistency analysis in {Bloom}: a {CALM} and collected approach.
\newblock In {\em CIDR 2011}.

\bibitem{hat-vldb}
P.~Bailis, A.~Davidson, A.~Fekete, A.~Ghodsi, J.~M. Hellerstein, and I.~Stoica.
\newblock Highly available transactions: Virtues and limitations.
\newblock In {\em VLDB 2014}.

\bibitem{coord-avoid}
P.~Bailis, A.~Fekete, M.~J. Franklin, A.~Ghodsi, J.~M. Hellerstein, and
  I.~Stoica.
\newblock When does consistency require coordination?
\newblock arXiv:1402.2237, 2014.
\newblock \url{http://arxiv.org/abs/1402.2237}.

\bibitem{ramp-txns}
P.~Bailis, A.~Fekete, A.~Ghodsi, J.~M. Hellerstein, and I.~Stoica.
\newblock Scaling atomic visibility with ramp transactions.
\newblock In {\em SIGMOD 2014}.

\bibitem{queue}
P.~Bailis and A.~Ghodsi.
\newblock {Eventual Consistency} today: Limitations, extensions, and beyond.
\newblock {\em ACM Queue}, 11(3), 2013.

\bibitem{tao}
N.~Bronson et~al.
\newblock {TAO}: {Facebook's} distributed data store for the social graph.
\newblock In {\em USENIX ATC 2013}.

\bibitem{spanner}
J.~C. Corbett et~al.
\newblock Spanner: Google's globally-distributed database.
\newblock In {\em OSDI 2012}.

\bibitem{gilbert-cap}
S.~Gilbert and N.~Lynch.
\newblock Brewer's conjecture and the feasibility of consistent, available,
  partition-tolerant web services.
\newblock {\em SIGACT News}, 33(2):51--59, 2002.

\bibitem{gray-book}
J.~Gray and A.~Reuter.
\newblock {\em Transaction processing}.
\newblock Kaufmann, 1993.

\bibitem{blink-tree}
P.~L. Lehman and S.~B. Yao.
\newblock Efficient locking for concurrent operations on {B-trees}.
\newblock {\em ACM Transactions on Database Systems (TODS)}, 6(4):650--670,
  1981.

\bibitem{crdt}
M.~Shapiro, N.~Pregui{\c{c}}a, C.~Baquero, and M.~Zawirski.
\newblock A comprehensive study of convergent and commutative replicated data
  types.
\newblock Technical Report 7506, INRIA, 2011.

\bibitem{f1}
J.~Shute et~al.
\newblock F1: A distributed {SQL} database that scales.
\newblock In {\em VLDB 2013}.

\bibitem{sharednothing}
M.~Stonebraker.
\newblock The case for shared nothing.
\newblock {\em IEEE Database Eng. Bull.}, 9(1):4--9, 1986.

\bibitem{stonebraker-blog}
M.~Stonebraker.
\newblock Why enterprises are uninterested in {NoSQL}, September 2010.
\newblock
  \url{http://cacm.acm.org/blogs/blog-cacm/99512-why-enterprises-are-uninterested-in-nosql/fulltext}.

\bibitem{tpcc}
{TPC Council}.
\newblock {TPC Benchmark C} revision 5.11, 2010.

\bibitem{bobtail}
Y.~Xu, Z.~Musgrave, B.~Noble, and M.~Bailey.
\newblock Bobtail: avoiding long tails in the cloud.
\newblock In {\em NSDI 2013}.

\bibitem{swift}
M.~Zawirski, A.~Bieniusa, V.~Balegas, S.~Duarte, C.~Baquero, M.~Shapiro, and
  N.~Pregui{\c{c}}a.
\newblock Swiftcloud: Fault-tolerant geo-replication integrated all the way to
  the client machine.
\newblock arXiv:1310.3107.

\end{thebibliography}

% flatex input end: [bcc.bbl]
%FLATEX-REM:\bibliography{bcc} \bibliographystyle{abbrv}

\end{document}

% flatex input end: [bcc.tex]
